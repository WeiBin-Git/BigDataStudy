#### 1、复杂度
##### 知识点
* 时间复杂度  空间复杂度
* 最好时间负责度 最坏时间复杂度 平均时间复杂度 均摊时间复杂度

#### 2、链表
##### 知识点
* 单链表 双链表 循环链表
* 链表和数组的对比
* 理解指针的含义
* 警惕指针丢失和内存泄露
* 利用哨兵简化实现难度（带头链表和不带头链表）
* 重点留意便捷条件的处理

##### 课后题
* 实现一个链表
* 单链表反转
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数第 n 个结点
* 求链表的中间结点
* 


#### 3、栈
##### 知识点
* 先进后出，后进先出，是一种**操作受限**的线性表
* 可以用数组实现--> 顺序栈  用链表时间 -->链式栈
* 时间复杂度和空间复杂度 O(1)  O(n)
* 支持动态扩容的顺序栈的时间复杂度分析
* 栈在函数调用中的作用
* 通过两个栈来实现表达式求值：一个栈保存操作数，另一个栈保存运算符
* 栈检查表达式中括号是否匹配
* 函数调用会使用栈来保存临时变量
##### 课后题
* 用链表实现一个栈
* 为什么用栈来保存函数变量，用其他数据结构可以吗
* 20,155,232,844,224,682,496.
* 

#### 4、队列
##### 知识点
* 先进先出，后进后出，操作受限
* 可以用数组 和 链表 实现
* 循环队列，阻塞队列， 并发队列
* 池结构一般会用到队列
##### 课后题
* 注意队列为空和满的判定条件
* 无锁并发队列
* CAS实现无锁队列
* 

#### 5、递归（如何查找最终推荐人）
##### 知识点
* 什么问题可以用递归
  *  一个问题的解可以分解成几个子问题的解
  *  问题与子问题除了数据规模不同，求解思路一样
  *  存在递归终止条件
* 递归代码需要警惕堆栈溢出
  * 可以限制递归调用的最大深度
* 递归要警惕重复计算
  * 可以使用散列表保存已经计算过的值
* 利： 表达力强，写起来简洁
* 弊： 空间复杂度高，有堆栈溢出的风险
* python 默认最大递归深度 998,可以手动修改
##### 课后题
* 如何调试递归代码
  * 打印日志，发现递归值
  * 结合条件断点进行调试
* 菲波那切数列


#### 6、排序
##### 知识点
* 评价分析排序算法
  * 排序算法执行效率
    * 最好情况，最坏情况，平均情况复杂度
    * 时间复杂度的系数，常数，低阶
    * 比较次数和交换移动次数
  * 排序算法的内存消耗
  * 排序算法的稳定性
  * 有序度 和 逆序度  满有序度
* 冒泡排序
  * 只涉及相邻数据的交换操作，空间复杂度O(1)，原地排序
  * 稳定的排序算法
  * 最好O(n)  最坏 O(n2) 平均 O(n2)
* 插入排序
  * 找到未排序区间元素 在已排序中找到合适的位置插入
  * 初始已排序区间为数组第一个
  * 原地排序
  * 稳定的排序算法
  * 最好 O(n)  最坏O(n2)  平均O(n2)
  * 优化-->希尔排序
* 选择排序
  * 从未排序区间中找到最小的元素，放到已排序区间的尾部
  * 不稳定的排序算法 
* 插入比冒泡好的原因：冒泡排序数据交换比插入排序移动复杂
* 归并排序
  * 将数组从中间分成前后两组，分别排序
  * 分治思想
  * 稳定的排序算法
  * 任何情况下时间复杂度 O(nLogn)
  * 归并排序执行效率与要排序数组的有序程序无关
  * 归并排序不是原地排序算法，空间复杂度是O(n)
  * 由下到上，先处理子问题，再合并
* 快速排序
  * 随机选取一个点，将小于这个点的放左边，大于放右边
  * 递归，分治思想
  * 不稳定的排序算法
  * 时间复杂度 O(nlogn)，最好O(nlogn),最坏O(n2)
* 线性排序
  * 非基于比较的排序算法，不会涉及元素的比较操作
  * 对要排序数据要求比较苛刻
  * 时间复杂度O(n)
* 桶排序
  * 将排序的数据分到几个有序的桶
  * 要排序的数据分到m个桶，桶与桶之间有着天然的大小顺序
  * 数据在各个桶内的数据比较均匀
  * 桶排序适用于外部排序
* 计数排序
  * 桶排序的一种特殊情况
  * 适用于数据范围不大的情况
  * 只适用于非负整数
* 基数排序
  * 排序每位的算法必须是稳定的
  * 需要可以分割出独立的位来比较


* 如何实现高性能排序函数
  * 如何优化快速排序
    * 快排会退化为O(n2)主要是分区点选取不合理
    * 三数取中法、五数取中
    * 随机取数
    * 
##### 课后题
* 插入排序，冒泡排序，选择排序是否可以基于链表实现
* 利用哨兵实现归并排序merge函数
* 利用快排在O(n)内寻找第K大元素
* 利用有限空间合并日志
* 如何根据年龄给100万数据排序
* 不同语言的sort方法都取得什么排序方法

#### 二分查找
##### 知识点
* 针对有序数据集合、数据无序需要先排序
* 二分查找依赖数组，不能依赖链表
* 只能用在插入，删除操作不频繁，一次排序，多次查找
* 数据量太小太大不适合二分查找
* 时间复杂度O(logn)
* 查找第一个值等于给定值的元素
* 查找最后一个值等于给定值的元素
* 查找第一个大于等于给定值的元素
* 查找最后一个小于等于给定值的元素

##### 课后题
* 递归和循环实现二分查找
* 求一个数的平方根，精确到后6位
* 用链表实现二分查找的时间复杂度
* 利用二分查找 在循环有序数组中查找


#### 跳表
* 性能比较优秀的动态数据结构，支持快速插入删除查找
* 链表+多级索引 = 跳表
* 时间复杂度O(logn)、基于单链表实现了二分查找
* 建立了很多级索引，通过空间换时间
* 空间复杂度O(n)
* 支持动态插入删除，时间复杂度O(logn)
* 跳表索引动态更新，通过随机函数将数据插入到部分索引中
* redis有序集合采用跳表+散列表实现

#### 散列表（Hash表）
##### 知识点
* 数组的一种拓展，用的是数组支持按照下标随机访问数据的特性
* 通过散列函数把元素的键值映射为下标
* 解决散列冲突问题
  * 开放寻址法：线性探测，二次探测，双重散列
  * 开放寻址法删除数据比较麻烦，数据量较小，装载因子小适合
  * 链表法，对内存利用率较高。对大装载因子容忍度较高，
* 如何设计应对各种情况的工业级散列表
  * 散列函数的设计不能太复杂
  * 散列函数生成的散列值尽可能随机且均匀
* 装载因子 = 填入表中的元素个数/散列表的长度


#### 链表+散列表
* 为什么经常组合在一起使用，如何组合使用的
* LRU缓存淘汰算法：散列表+双向链表
* Redis
* LinkedHashMap：支持LRU缓存淘汰策略的，双向链表+散列表


#### 哈希算法
* 如何防止数据库中用户信息被脱库
* 将任意长度二进制值串映射到固定长度
  * 从哈希值不能反向推导
  * 对输入数据比较敏感
  * 散列冲突概率要很小
  * 执行效率要高
* 应用(安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储)
  * 安全加密（MD5、SHA、DES、AES）
  * 唯一标识
  * 数据校验
  * 散列函数
  * 负载均衡
* 一致性哈希算法


#### 二叉树
##### 知识点
* 父节点、子节点、兄弟节点、根节点、叶子节点
* 高度：节点到叶子节点的最长路径（从下往上度量）
* 深度：跟节点到这个节点所经历的边数（从上往下度量）
* 层：节点深度+1
* 树的高度：根节点的高度
* 二叉树：每个节点最多只有两个子节点，分别是左子节点和右子节点
* 满二叉树：叶子节点全部都在最底层，除了叶子节点，每个节点都有两个子节点
* 完全二叉树：除了最后一层，其他层的节点数都要达到最大，最后一层叶子节点都靠左排列
* 存储二叉树
  * 链式存储法
  * 基于数组的顺序存储法，适合存储完全二叉树
* 二叉树的遍历（前中后表示节点与它左右子树节点遍历打印的先后顺序）
  * 时间复杂度O(n)
  * 前序遍历：
  * 中序遍历
  * 后序遍历

##### 课后题
* 前中后序遍历实现
* 给定一组数据，可以构建出多少不同的二叉树
* 按层遍历二叉树的实现方式


#### 二叉查找树
##### 知识点
* 支持动态数据组合的快速插入，删除，查找
* 支持快速查找最大节点，最小节点，前驱节点，后驱节点
* 树中的每一个节点，左子树中每个节点的值必须小于这个节点的值，右子树中每个节点的值都要大于这个节点的值
* 中序遍历，可以输出有序的数据序列，时间复杂度O(n)
* 二叉查找树的时间复杂度跟高度成正比，极端情况下是O(n)和O(logn)，分别对应于退化为链表和完全二叉树的情况
* 平衡二叉查找树的时间复杂度：插入，删除，查找 O(logn)比较稳定
* 二叉查找树相对于散列表的优势
  * 散列表中数据无序存贮
  * 散列表扩容耗时多
  * 由于哈希冲突的存在，时间复杂度不一定比O(logn)小
  * 散列表构造比二叉查找树复杂
  * 散列表装载因子不能太大

#### 红黑树、平衡二叉查找树的一种
##### 知识点
* 二叉查找树在频繁的动态更新过程中，时间复杂度会退化
* Red-Black-Tree
  * 根节点是黑色的
  * 每个叶子节点都是黑色的空节点
  * 任何相邻的节点都不能同时为红色
  * 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数据的黑色节点
* 红黑树的实现
  * 左旋：围绕某个节点的左旋
  * 右旋：围绕某个节点的右旋
  * 插入：
    * 插入的节点必须是红色的

#### 堆和堆排序
##### 知识点
* 堆排序：原地，时间复杂度O(nlogn)
* 堆是一个完全二叉树
* 堆中每个节点的值都大于等于或小于等于子树中每个节点的值
* 大顶堆，小顶堆
* 堆化：从下往上，从上往下（比较和交换）
* 添加一个元素，将元素添加到最后，然后依次向上比较交换
* 删除堆顶元素，将最后一个元素放在要删除的位置，然后依次向下比较交换，不会存在空洞
* 堆化的时间复杂度跟数的高度成正比O(logn)
* 堆排序
   * 时间复杂度：O(nlogn) 稳定
   * 原地排序
   * 建堆：时间复杂度O(n)
   * 排序：时间复杂度O(nlogn)
   * 不稳定的排序算法
* 堆排序对比快排
  * 堆排序数据访问的方式没有快排友好
  * 对于同样的数据，排序过程中，堆排序算法数据的交换次数要多于快排
* 堆的应用
  * 优先级队列
  * TOPK
  * 利用堆求中位数
##### 课后题
* 实现一个堆


#### 图
##### 知识点
* 有向图，无向图，顶点，度，入度，出度，带权图
* 存储方法：邻接矩阵，邻接表，逆邻接表


#### 深度优先和广度优先搜索
##### 知识点
* 广度优先搜索：BFS
  * 时间复杂度：O(V+E)  V:顶点的个数，E:边的个数
  * 空间复杂度：O(V)
* 深度优先搜索：DFS
  * 时间复杂度：O(E)
  * 空间复杂度：O(V)
* 二叉树的深度优先搜索和广度优先搜索
  * 深度优先：前序，中序，后序
  * 利用堆栈实现二叉树的遍历
 
#### 如何实现高效的字符串匹配
##### 知识点
* BF算法
  * 暴力匹配算法
  * 主串和模式串
  * 在主串中，检查起始位置分别是0,1,2...n-m 且长度为m的n-m+1个子串，看有没有跟模式串匹配的
* RK算法
  * 将子串求哈希值与模式串的哈希值进行比较
  * 相邻两个子串的哈希值的计算有重合部分，可以用来简化哈希值的计算
* BM算法
  * 坏字符规则
  * 好后缀规则
* KMP算法
* Trie树：字典树
  * 专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题
  * 
* AC自动机
* 

#### 贪心算法
##### 知识点
* 如何使用贪心算法实现霍夫曼压缩编码
* 适用场景
  *  在满足限制值的情况下，期望值最大
  *  每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据
* 贪心算法解决问题的思路，并不能给出最优解
* 如何将要解决的问题抽象成贪心算法模型


##### 课后题
* 在一个非负整数a中，希望从中溢出k个数字，让剩下的数字最小，如何选择移除哪几个数字

#### 分支算法
##### 知识点
* 适用场景
   *  原问题与分解成的小问题具有相同的模式
   *  原问题分解成的子问题可以独立求解，子问题之间没有关联性
   *  具有分解终止条件
   *  可以将子问题合并，合并操作复杂度不能太高
* 课后题
  * 二维平面有n个点，如何快速计算出两个距离最近的点对
  * 两个n * n的矩阵，快速计算两个矩阵的乘积


#### 回溯算法
##### 知识点
* 从一个可能的解中，选择一个满足要求的解
* 利用剪枝，过滤不需要穷举搜索所有的情况
* 0-1背包
* 正则表达式匹配
* 八皇后问题数独
* 全排列
* 图的着色
* 旅行商问题
* 适合使用递归代码实现
* 

#### 动态规划
##### 知识点
* 适合场景
  *  适合求解最优问题
  *  多阶段决策最优解模型
  *  最优子结构
  *  无后效性
  *  重复子问题
* 两种思路
   * 状态转移表法
   * 状态转移方程法：类似于递归，寻找最优子结构
* 把问题分为多个阶段，每个阶段对应一种决策，记录每一个阶段可达的状态集合，然后通过当前阶段的状态集合来推导下一个阶段的状态集合，动态的向前推进
* 动态规划时间效率较高，但对空间消耗较多
* 
##### 课后题
* 杨辉三角计算最短路径

